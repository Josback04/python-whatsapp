# app/modules/formulaire.py
import logging
from app.questions import QUESTIONS # Importer les questions
from app.database.database import save_response_to_db
from app.services.gemini import ask_ai
from app.services.docx_service import generate_docx
CATEGORY_ORDER = list(QUESTIONS.keys())

def start_formulaire(wa_id):
    """Initialise l'Ã©tat pour le module formulaire."""
    logging.info(f"DÃ©marrage du module FORMULAIRE pour {wa_id}")
    category_index = 0
    question_index = 0
    current_category = CATEGORY_ORDER[category_index]
    response = QUESTIONS[current_category][question_index]
    
    # Le premier message est spÃ©cial (Bienvenue), on peut l'adapter si besoin
    response = f"CommenÃ§ons le formulaire ! ðŸ˜Š\n\n{response}" 

    state = {
        "module": "FORMULAIRE",
        "category_index": category_index,
        "question_index": question_index,
    }
    state["response"] = response # Ajouter la rÃ©ponse Ã  envoyer dans l'Ã©tat retournÃ©
    return state

def handle_message(wa_id, message_body, state):
    """GÃ¨re un message lorsque l'utilisateur est dans le module formulaire."""
    logging.info(f"Traitement FORMULAIRE pour {wa_id}: {message_body}")
    
    category_index = state.get("category_index", 0)
    question_index = state.get("question_index", 0)
    current_category = CATEGORY_ORDER[category_index]

    # *** SAUVEGARDE EN BASE DE DONNÃ‰ES ***
    # RÃ©cupÃ©rer le texte de la question Ã  laquelle l'utilisateur vient de rÃ©pondre
    try:
        question_asked = QUESTIONS[current_category][question_index]
        # Sauvegarder la rÃ©ponse de l'utilisateur (message_body) pour la question posÃ©e
        save_response_to_db(wa_id, question_asked, message_body)
        # Si la sauvegarde Ã©choue, on loggue l'erreur mais on continue le flux normal
    except IndexError:
        logging.error(f"IndexError lors de la rÃ©cupÃ©ration de la question pour la sauvegarde DB: cat={current_category}, index={question_index}")
    except Exception as e:
         logging.exception(f"Erreur inattendue lors de la sauvegarde DB pour {wa_id}: {e}")
    # **************************************

    # Passer Ã  la question suivante (logique existante)
    
    # Optionnel: Sauvegarder la rÃ©ponse prÃ©cÃ©dente
    # question_key = f"{current_category}_{question_index}"
    # state.setdefault("responses", {})[question_key] = message_body

    # Passer Ã  la question suivante
    question_index += 1

    if question_index >= len(QUESTIONS[current_category]):
        # Passer Ã  la catÃ©gorie suivante
        category_index += 1
        question_index = 0
        if category_index >= len(CATEGORY_ORDER):
            # Fin du formulaire
            response = "Merci d'avoir rÃ©pondu Ã  toutes les questions du formulaire ! ðŸ˜Š"
            


            # Indiquer la fin pour que le routeur supprime l'Ã©tat

            state = {"module": "FINISHED", "response": response} 
            ai_response=ask_ai(wa_id)
            generate_docx(wa_id,ai_response)

            return state
        else:
            current_category = CATEGORY_ORDER[category_index]
            response = QUESTIONS[current_category][question_index]
            state["category_index"] = category_index
            state["question_index"] = question_index
            state["response"] = response
            return state
    else:
        # Question suivante dans la mÃªme catÃ©gorie
        response = QUESTIONS[current_category][question_index]
        state["question_index"] = question_index
        state["response"] = response
        return state